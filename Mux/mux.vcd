$date
	Sun Sep  1 14:33:45 2019
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module BUF $end
$var wire 1 ! A $end
$var wire 1 " Y $end
$upscope $end
$scope module DFFSR $end
$var wire 1 # C $end
$var wire 1 $ D $end
$var wire 1 % R $end
$var wire 1 & S $end
$var reg 1 ' Q $end
$upscope $end
$scope module NOR $end
$var wire 1 ( A $end
$var wire 1 ) B $end
$var wire 1 * Y $end
$upscope $end
$scope module mux_tb $end
$var wire 1 + sel $end
$var wire 1 , reset $end
$var wire 1 - out_e $end
$var wire 1 . out_c $end
$var wire 2 / data_in [1:0] $end
$var wire 1 0 clk $end
$scope module mux_c $end
$var wire 1 + sel $end
$var wire 1 , reset $end
$var wire 2 1 data_in [1:0] $end
$var wire 1 0 clk $end
$var reg 1 2 f_out_c $end
$var reg 1 . out_c $end
$upscope $end
$scope module mux_e $end
$var wire 1 + sel $end
$var wire 1 , reset $end
$var wire 1 - out_e $end
$var wire 1 3 f_out_e $end
$var wire 2 4 data_in [1:0] $end
$var wire 1 0 clk $end
$var wire 1 5 _07_ $end
$var wire 1 6 _06_ $end
$var wire 1 7 _05_ $end
$var wire 1 8 _04_ $end
$var wire 1 9 _03_ $end
$var wire 1 : _02_ $end
$var wire 1 ; _01_ $end
$var wire 1 < _00_ $end
$scope module _08_ $end
$var wire 1 6 Y $end
$var wire 1 , A $end
$upscope $end
$scope module _09_ $end
$var wire 1 5 Y $end
$var wire 1 + A $end
$upscope $end
$scope module _10_ $end
$var wire 1 6 A $end
$var wire 1 ; Y $end
$var wire 1 3 B $end
$upscope $end
$scope module _11_ $end
$var wire 1 = A $end
$var wire 1 : Y $end
$var wire 1 + B $end
$upscope $end
$scope module _12_ $end
$var wire 1 > A $end
$var wire 1 5 B $end
$var wire 1 9 Y $end
$upscope $end
$scope module _13_ $end
$var wire 1 : A $end
$var wire 1 9 B $end
$var wire 1 8 Y $end
$upscope $end
$scope module _14_ $end
$var wire 1 8 B $end
$var wire 1 7 Y $end
$var wire 1 , A $end
$upscope $end
$scope module _15_ $end
$var wire 1 7 A $end
$var wire 1 < Y $end
$upscope $end
$scope module _16_ $end
$var wire 1 ; A $end
$var wire 1 7 B $end
$var wire 1 - Y $end
$upscope $end
$scope module _17_ $end
$var wire 1 < D $end
$var wire 1 0 C $end
$var reg 1 3 Q $end
$upscope $end
$upscope $end
$scope module mux_t $end
$var wire 1 . out_c $end
$var wire 1 - out_e $end
$var reg 1 0 clk $end
$var reg 2 ? data_in [1:0] $end
$var reg 1 , reset $end
$var reg 1 + sel $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx ?
x>
x=
x<
x;
x:
x9
x8
x7
x6
x5
bx 4
x3
x2
bx 1
x0
bx /
x.
x-
x,
x+
x*
z)
z(
x'
z&
z%
z$
z#
z"
z!
$end
#310
00
#400
19
0<
17
0>
1=
16
0.
02
b10 /
b10 1
b10 4
b10 ?
0,
10
#500
00
#600
0-
18
09
1;
1:
1>
15
03
b11 /
b11 1
b11 4
b11 ?
0+
10
#700
00
#800
1-
19
1<
0:
07
05
0>
06
1.
1+
b10 /
b10 1
b10 4
b10 ?
1,
10
#900
00
#1000
09
1:
15
1>
0=
13
0+
b1 /
b1 1
b1 4
b1 ?
12
10
#1100
00
#1200
19
0:
05
1=
1+
b11 /
b11 1
b11 4
b11 ?
10
#1300
00
#1400
0-
0<
17
08
1:
0>
0=
0.
b0 /
b0 1
b0 4
b0 ?
10
#1500
00
#1600
1-
1<
07
18
09
15
1>
1=
1.
02
0+
b11 /
b11 1
b11 4
b11 ?
03
10
#1700
00
#1800
19
0:
05
0>
13
1+
b10 /
b10 1
b10 4
b10 ?
12
10
#1900
00
#2000
09
1:
15
1>
0=
0+
b1 /
b1 1
b1 4
b1 ?
10
#2100
00
#2200
10
#2300
00
#2400
10
